#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include "tict.h"

#define LONGEST_WORD 48
#define UNUSED(x) (void)x

int main(int argc, char *argv[]) {
    // init
    char *path = (char *)calloc(sizeof(char), LONGEST_WORD);
    snprintf(path, LONGEST_WORD, "%s/.config/tict/words.db", getenv("HOME"));
    sqlite3 *words_db = NULL;
    int result = access(path, W_OK);
    sqlite3_open(path, &words_db);
    if(result!=0) {
        char *err;
        if(sqlite3_exec(words_db, "create table words(id integer primary key autoincrement, word text, pronunciation text, meaning text, query_count integer default 0);", NULL, NULL, &err)!=SQLITE_OK)
        perror(err);
    }

    switch(argc) {
        case 1:
            usage();
            break;
        case 2:
            if(strcmp(argv[1], "update")==0) {
                printf("updating...\n");
                update_db(words_db);
                printf("update success, you can clear $HOME/.words now.\n");
            }
            else if(strcmp(argv[1], "clean")==0) {
                clean_db(words_db);
                printf("clean success\n");
            }
            else if(strcmp(argv[1], "random")==0) {
                Word *word;
                word = NULL;
                word = random_word(words_db);
                print_word(word);
                free_word(word);
            }
            else if(strcmp(argv[1], "top")==0) {
                Word ** result = (Word**)malloc(sizeof(Word*)*10);
                for(int i=0; i<10; i++) {
                    result[i] = (Word*)malloc(sizeof(Word));
                    result[i]->word = (char *)calloc(sizeof(char), LONGEST_WORD);
                    result[i]->pronunciation = (char *)calloc(sizeof(char), LONGEST_WORD);
                    result[i]->meaning = (char *)calloc(sizeof(char), BUFSIZ);
                }
                printf("You are here\n");
                result = top_word(words_db, result);
                for(int i=0; i<0; i++) {
                    print_word(result[i]);
                    free_word(result[i]);
                }
                free(result);
            } else
                usage();
        case 3: {
            Word *word = NULL;
            word = query_word(words_db, argv[2]);
            if(word!=NULL) {
                print_word(word);
                free_word(word);
            }
            break;
        }
        default:
            usage();
    }
    // clean
    free(path);
    sqlite3_close(words_db);
    return 0;
}

void usage() {
    printf("\e[33;1mtict: dict in terminal with query record saved in local database.\n\e[0m");
    printf("usage: tict [command]\n");
    printf("command:\n");
    printf("         update: insert cache data to database\n");
    printf("                 cache data is a plain text which is generated by dict script and stored in $HOME/.words\n");
    printf("         clean: delete data in table.\n");
    printf("         query: query a word from database.\n");
    printf("         top: show the top 10 words you most queried.\n");
    printf("         random: pick up a random word from database.\n");
    printf("         help: print this usage info.\n");

}

void print_word(Word *word) {
    printf("%s\e[32;1mUK\e[0m: %s%s", word->word,word->pronunciation,word->meaning);
}

void free_word(Word *word) {
    free(word->word);
    free(word->meaning);
    free(word->pronunciation);
    free(word);
}

int query_callback(void *data, int column_count, char **column_value, char **column_name) {
    UNUSED(column_count);
    UNUSED(column_name);
    Word *word = (Word *)data;
    word->word = (char *)calloc(sizeof(char), LONGEST_WORD);
    word->pronunciation = (char *)calloc(sizeof(char), LONGEST_WORD);
    word->meaning = (char *)calloc(sizeof(char), BUFSIZ);
    strncpy(word->word, column_value[1], strlen(column_value[1]));
    strncpy(word->pronunciation, column_value[2], strlen(column_value[2]));
    strncpy(word->meaning, column_value[3], strlen(column_value[3]));
	return 0;
}

void update_db(sqlite3 *words_db) {
    char *path = (char *)calloc(sizeof(char), LONGEST_WORD);
    snprintf(path, LONGEST_WORD, "%s/.words", getenv("HOME"));
    FILE *words = fopen(path, "r");
    if(words==NULL)
        perror(path);
    Word *word = (Word *)malloc(sizeof(Word));
    word->word = (char *)calloc(sizeof(char), LONGEST_WORD);
    word->pronunciation = (char *)calloc(sizeof(char), LONGEST_WORD);
    word->meaning = (char *)calloc(sizeof(char), BUFSIZ);

    char line[BUFSIZ];
    int line_count = 1;

    while((fgets(line, BUFSIZ, words)) != NULL) {
        if(strcmp(line, "\n")==0) {
            line_count = 1;
            sprintf(line,
                    "insert into words(word, pronunciation, meaning) values(\"%s\", \"%s\", \"%s\");",
                    word->word, word->pronunciation, word->meaning);
            sqlite3_exec(words_db, line, NULL, NULL, NULL);
            memset(word->word, 0, LONGEST_WORD);
            memset(word->pronunciation, 0, LONGEST_WORD);
            memset(word->meaning, 0, BUFSIZ);
            continue;
        }
        switch(line_count) {
        case 1:
            strncpy(word->word, line, strlen(line));
            break;
        case 2:
            if(line[0]=='[')
                strncpy(word->pronunciation, line, strlen(line));
            break;
        default:
            if(line[0]!='-')
                strncat(word->meaning, line, strlen(line));
            break;
        }
        line_count++;
    }
    free_word(word);
    fclose(words);
    free(path);
}

void clean_db(sqlite3 *words_db) {
    sqlite3_exec(words_db, "delete from words; vacuum;", NULL, NULL, NULL);
    sqlite3_exec(words_db, "UPDATE \"main\".\"sqlite_sequence\" SET seq = 0 WHERE name = 'words';", NULL, NULL, NULL);
}

Word * query_word(sqlite3 *words_db, char *word) {
    Word *result = (Word *)malloc(sizeof(Word));
    result->word = NULL;
    char *sql = (char *)calloc(sizeof(char) , BUFSIZ);
    sprintf(sql, "select * from words where word like \"%%%s%%\"", word);
    sqlite3_exec(words_db, sql, query_callback, result, NULL);
    if(result->word == NULL) {
        free(result);
        result = NULL;
    }
    free(sql);
    return result;
}

Word ** top_word(sqlite3 *words_db, Word **result) {
    sqlite3_stmt *stmt = NULL;
    const char *zTail;

    if(sqlite3_prepare(words_db, "select * from words order by query_count desc limit 10;", -1, &stmt, &zTail) == SQLITE_OK) {
        int i = 0;
        while( sqlite3_step(stmt) == SQLITE_ROW ) { 
            result[i]->word = (char *)sqlite3_column_text(stmt, 1);
            result[i]->pronunciation = (char *)sqlite3_column_text(stmt, 2);
            result[i]->meaning = (char *)sqlite3_column_text(stmt, 3);
            i++;
        } 
    }
    return result;
}

Word * random_word(sqlite3 *words_db) {
    Word *result = (Word *)malloc(sizeof(Word));
    sqlite3_exec(words_db, "select * from words order by random() limit 1;", query_callback, result, NULL);
    return result;
}
